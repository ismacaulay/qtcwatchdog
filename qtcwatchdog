#!/usr/bin/env python
import os, sys, time, logging
from argparse import ArgumentParser
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

import utilities
from validator import PathValidator
from writer import QtcFileWriter
from file import QtcFile
from updater import QtcUpdater

def main():
   parser = ArgumentParser(description='A file system watcher for QtCreator')
   parser.add_argument('--proj', type=str, default=None,
                       help='The name of the QtCreator project, (Default=CWD directory name)')
   parser.add_argument('--path', type=str, default=None,
                       help='Path to the QtCreator project files.')
   parser.add_argument('--watch', type=str, default=None,
                       help='Base path to watch. Recursively watches all sub directories. (Default=CWD)')
   parser.add_argument('--includes', default='',
                       help='Include directory base paths seperated by a semicolon. Recursively adds all sub directories. Path specified by --path automatically included. (Ex. C:\hello;C:\world)')
   parser.add_argument('--patterns', type=str, default='',
                       help='File patterns to watch seperated by a semicolon. (Ex: *.h;*.py;wscript) Note: No regex support, only *. and full names supported.')
   parser.add_argument('--excludes', type=str, default='',
                       help='Directories to exclude from watching seperated by a semicolon. (Ex hello;world;test) Note: No regex support')
   parser.add_argument('-v', '--verbose', action='store_true', default=False,
                       help='Print messages about what is happening.')
   args = parser.parse_args()
   if args.verbose:
      logging.basicConfig(format='[%(levelname)s] %(message)s', level=logging.DEBUG)
   else:
      logging.basicConfig(format='[%(levelname)s] %(message)s', level=logging.CRITICAL)

   if not args.path and args.watch:
      args.path = args.watch
   elif args.path and not args.watch:
      args.watch = args.path
   elif not args.path and not args.watch:
      args.path = os.getcwd()
      args.watch = os.getcwd()

   if not args.proj:
      args.proj = os.path.basename(args.path)

   _print_settings(args)

   includes = utilities.split_semicolon(args.includes)
   patterns = utilities.split_semicolon(args.patterns)
   excludes = utilities.split_semicolon(args.excludes)

   utilities.check_path_exists(args.watch)

   (files, dirs) = _all_files_and_dirs(args.watch, includes)

   validator = PathValidator(patterns, excludes, dirs)

   qtcfiles_path = os.path.join(args.path, '{0}.files'.format(str(args.proj)))
   utilities.check_path_exists(qtcfiles_path)
   qtcfiles_writer = QtcFileWriter(qtcfiles_path, args.path, [args.watch])
   qtc_files = QtcFile(qtcfiles_path, validator, qtcfiles_writer, files)

   qtcincludes_path = os.path.join(args.path, '{0}.includes'.format(str(args.proj)))
   utilities.check_path_exists(qtcincludes_path)
   basepaths = [args.watch]
   basepaths.extend(includes)
   qtcincludes_writer = QtcFileWriter(qtcincludes_path, args.path, basepaths)
   qtc_includes = QtcFile(qtcincludes_path, validator, qtcincludes_writer, dirs)

   updater = QtcUpdater(qtc_files, qtc_includes)
   watchdog = QtcWatchdog(args.watch, updater)
   watchdog.start()

def _print_settings(args):
   print('Settings:')
   for arg,value in vars(args).items():
      print('   {0}: {1}'.format(str(arg), str(value)))
   print('   Logging: ' + str(args.verbose) + '\n')

def _all_files_and_dirs(watch, includes):
   (files, dirs) = utilities.all_files_and_dirs(watch)
   for inc in includes:
      (f, d) = utilities.all_files_and_dirs(inc)
      files.extend(f)
      dirs.extend(d)
   return (files, dirs)

class QtcWatchdog():
   def __init__(self, path, updater):
      self._path = path
      self._event_handler = QtcWatchdog.EventHandler(updater)
      self._observer = Observer()
      self._observer.schedule(self._event_handler, self._path, recursive=True)

   def start(self):
      self._observer.start()
      try:
         while True:
            if self._observer.isAlive():
               time.sleep(1)
            else:
               self._restart()
      except KeyboardInterrupt:
         self._observer.stop()
      self._observer.join()

   def _restart(self):
      self._observer.stop()
      self._observer = Observer()
      self._observer.schedule(self._event_handler, self._path, recursive=True)
      self._observer.start()

   class EventHandler(FileSystemEventHandler):
      def __init__(self, updater):
         self._updater = updater

      def on_created(self, event):
         logging.debug('EventHandler::on_created ' + str(event.src_path))
         self._updater.add(event.src_path, event.is_directory)

      def on_deleted(self, event):
         logging.debug('EventHandler::on_deleted ' + str(event.src_path))
         self._updater.remove(event.src_path, event.is_directory)

      def on_moved(self, event):
         logging.debug('EventHandler::on_moved src=' + str(event.src_path) + ' dest=' + str(event.dest_path))
         self._updater.move(event.src_path, event.dest_path, event.is_directory)

if __name__ == '__main__':
   main()
